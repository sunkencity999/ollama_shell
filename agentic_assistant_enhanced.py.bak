#!/usr/bin/env python3
"""
Enhanced Agentic Assistant for Ollama Shell

This module extends the original AgenticAssistant with task management capabilities
for handling complex, multi-step tasks. It integrates the TaskManager, TaskPlanner,
and TaskExecutor to break down complex requests into manageable subtasks.
"""

import os
import sys
import json
import logging
import asyncio
import re
from typing import Dict, Any, List, Optional, Union
from pathlib import Path
from rich.console import Console
from rich.markdown import Markdown
from rich.panel import Panel
from rich.prompt import Prompt
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn
from rich.table import Table
from rich.syntax import Syntax

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("agentic_assistant_enhanced")

# Import the original AgenticAssistant
from agentic_assistant import AgenticAssistant, console

# Import the task management system
from task_manager import TaskManager, TaskPlanner, TaskExecutor, TaskStatus

class EnhancedAgenticAssistant(AgenticAssistant):
    """
    Enhanced Agentic Assistant with task management capabilities.
    Extends the original AgenticAssistant to handle complex, multi-step tasks.
    """
    
    def __init__(self, model: Optional[str] = None):
        """
        Initialize the Enhanced Agentic Assistant.
        
        Args:
            model: The Ollama model to use for task execution
        """
        super().__init__(model)
        
        # Initialize task management components
        self.task_manager = TaskManager()
        self.task_planner = TaskPlanner(self.agentic_ollama)
        self.task_executor = TaskExecutor(self, self.task_manager)
        
        logger.info("Initialized EnhancedAgenticAssistant with task management capabilities")
    
    async def execute_complex_task(self, task_description: str) -> Dict[str, Any]:
        """
        Execute a complex, multi-step task by breaking it down into subtasks.
        
        Args:
            task_description: Natural language description of the complex task
            
        Returns:
            Dict containing the execution results
        """
        console.print(f"[bold blue]Analyzing complex task:[/bold blue] {task_description}")
        
        try:
            # Step 1: Plan the task
            with Progress(
                SpinnerColumn(),
                TextColumn("[bold blue]Planning task...[/bold blue]"),
                BarColumn(),
                TimeElapsedColumn(),
                console=console
            ) as progress:
                task = progress.add_task("Planning", total=1)
                
                # Plan the task using the TaskPlanner
                workflow_id = await self.task_planner.plan_task(task_description)
                progress.update(task, completed=1)
            
            # Step 2: Display the task plan
            self._display_task_plan(workflow_id)
            
            # Step 3: Execute the workflow
            with Progress(
                SpinnerColumn(),
                TextColumn("[bold blue]Executing tasks...[/bold blue]"),
                BarColumn(),
                TimeElapsedColumn(),
                console=console
            ) as progress:
                task = progress.add_task("Executing", total=100)
                
                # Start the execution
                execution_task = asyncio.create_task(self.task_executor.execute_workflow(workflow_id))
                
                # Update progress while execution is running
                while not execution_task.done():
                    # Get current workflow status
                    status = self.task_manager.get_workflow_status()
                    progress_percentage = status["progress_percentage"]
                    
                    # Update progress bar
                    progress.update(task, completed=progress_percentage)
                    
                    # Wait a bit before checking again
                    await asyncio.sleep(0.5)
                
                # Get the final result
                result = await execution_task
                progress.update(task, completed=100)
            
            # Step 4: Display the execution results
            return self._display_execution_results(workflow_id)
            
        except Exception as e:
            logger.error(f"Error executing complex task: {str(e)}")
            return {
                "success": False,
                "task_type": "complex_task",
                "error": str(e),
                "message": f"Failed to execute complex task: {str(e)}"
            }
    
    def _display_task_plan(self, workflow_id: str) -> None:
        """
        Display the task plan to the user.
        
        Args:
            workflow_id: ID of the workflow to display
        """
        # Load the workflow
        self.task_manager.load_workflow(workflow_id)
        
        # Get all tasks
        tasks = self.task_manager.get_all_tasks()
        
        # Create a table to display the task plan
        table = Table(title="Task Execution Plan")
        table.add_column("Step", style="cyan")
        table.add_column("Task", style="green")
        table.add_column("Type", style="yellow")
        table.add_column("Dependencies", style="magenta")
        
        # Add tasks to the table
        for i, task in enumerate(tasks, 1):
            # Format dependencies
            if task.dependencies:
                # Map dependency IDs to step numbers for better readability
                dep_steps = []
                for dep_id in task.dependencies:
                    # Find the index of the dependency task
                    for j, t in enumerate(tasks, 1):
                        if t.id == dep_id:
                            dep_steps.append(str(j))
                            break
                
                dependencies = ", ".join(dep_steps)
            else:
                dependencies = "None"
            
            table.add_row(
                str(i),
                task.description[:50] + ("..." if len(task.description) > 50 else ""),
                task.task_type.replace("_", " ").title(),
                dependencies
            )
        
        # Display the table
        console.print(Panel(table, title="Task Execution Plan", border_style="blue"))
        console.print("[bold green]Starting task execution...[/bold green]")
    
    def _is_direct_file_creation_task(self, task_description: str) -> bool:
        """
        Determine if a task is a direct file creation task that should be handled directly.
        
        Args:
            task_description: Description of the task
            
        Returns:
            True if the task is a direct file creation task, False otherwise
        """
        # Pattern 1: Create a file/document with...
        pattern1 = r"create\s+(?:a|an)\s+(?:file|document|text|story|poem|essay|article|report|note|analysis|summary|list)\s+(?:with|about|for|containing|of|on)"
        if re.search(pattern1, task_description, re.IGNORECASE):
            logger.info(f"Detected direct file creation task: '{task_description}'. Handling directly.")
            return True
        
        # Pattern 2: Write a story/poem/essay...
        pattern2 = r"write\s+(?:a|an|the)\s+(?:story|poem|essay|article|report|note|text|document|analysis|summary|list)"
        if re.search(pattern2, task_description, re.IGNORECASE):
            logger.info(f"Detected direct file creation task: '{task_description}'. Handling directly.")
            return True
        
        # Pattern 3: Save as filename...
        pattern3 = r"save\s+(?:it|this|the\s+file|the\s+document|the\s+content|the\s+result|the\s+output|that|the\s+analysis|the\s+summary)\s+(?:as|to|in)\s+([\w\-\.\s/]+)"
        if re.search(pattern3, task_description, re.IGNORECASE):
            logger.info(f"Detected direct file creation task with save pattern: '{task_description}'. Handling directly.")
            return True
        
        # Pattern 4: Create a file named/called...
        pattern4 = r"(?:create|make|write)\s+(?:a|an|the)\s+(?:file|document)\s+(?:named|called)"
        if re.search(pattern4, task_description, re.IGNORECASE):
            logger.info(f"Detected direct file creation task with named file: '{task_description}'. Handling directly.")
            return True
        
        # Pattern 5: Save to folder or file...
        pattern5 = r"save\s+(?:it|this|that|the\s+content|the\s+result|the\s+output)?\s+(?:to|in)\s+(?:my\s+)?(?:[\w\s]+\s+)?(?:folder|directory|file|document)\s+(?:as|named|called)?\s*"
        if re.search(pattern5, task_description, re.IGNORECASE):
            logger.info(f"Detected direct file creation task with folder/file path: '{task_description}'. Handling directly.")
            return True
        
        # Pattern 6: Look for quoted filenames or filenames with extensions
        pattern6 = r'(?:["\']+[\w\-\.\s]+\.[\w]+["\']+|\b[\w\-\.]+\.[a-zA-Z0-9]{2,4}\b)' 
        if re.search(pattern6, task_description, re.IGNORECASE) and any(term in task_description.lower() for term in ["create", "write", "save", "store", "output", "generate"]):
            logger.info(f"Detected direct file creation task with filename: '{task_description}'. Handling directly.")
            return True
            
        # Pattern 7: Compile/analyze/summarize and save
        pattern7 = r"(?:compile|analyze|summarize)\s+(?:[\w\s]+)\s+(?:and|then)\s+(?:save|store|write|output)"
        if re.search(pattern7, task_description, re.IGNORECASE):
            logger.info(f"Detected direct file creation task with compilation: '{task_description}'. Handling directly.")
            return True
            
        # Pattern 8: File named/called pattern
        pattern8 = r"(?:file|document|text)\s+(?:named|called)\s+['\"]?([\w\s\.\-]+)['\"]?"
        if re.search(pattern8, task_description, re.IGNORECASE):
            logger.info(f"Detected direct file creation task with named file: '{task_description}'. Handling directly.")
            return True
            
        # Pattern 9: Complex pattern for search and save
        pattern9 = r"(?:search|find|look\s+for|research|get\s+information\s+about)\s+(?:[\w\s\d\-\+]+)\s+(?:and|then)\s+(?:save|store|write|create)\s+(?:it|that|them|the\s+results?|the\s+information|a\s+file|a\s+document)"
        if re.search(pattern9, task_description, re.IGNORECASE):
            logger.info(f"Detected complex file creation task with search and save: '{task_description}'. Handling directly.")
            return True
            
        # Pattern 10: Search for X and save to file Y
        pattern10 = r"(?:search|find|look\s+for|research|get\s+information\s+about)\s+(?:[\w\s\d\-\+]+)\s+(?:and|then)\s+(?:save|store|write)\s+(?:it|that|them|the\s+results?|the\s+information)\s+(?:to|in|as)\s+(?:a\s+)?(?:file|document)\s+(?:named|called)?\s+['\"]?([\w\s\.\-]+)['\"]?"
        if re.search(pattern10, task_description, re.IGNORECASE):
            logger.info(f"Detected complex file creation task with search and named file: '{task_description}'. Handling directly.")
            return True
            
        # Pattern 11: Generate/create X based on search/web results
        pattern11 = r"(?:generate|create|write|make|prepare)\s+(?:a|an|the)\s+(?:summary|report|analysis|document|file|list|compilation)\s+(?:of|about|on|for)\s+(?:[\w\s\d\-\+]+)\s+(?:based\s+on|using|from|with)\s+(?:search|web|internet|online)\s+(?:results|information|data|content)"
        if re.search(pattern11, task_description, re.IGNORECASE):
            logger.info(f"Detected complex file creation task with web research: '{task_description}'. Handling directly.")
            return True
            
        # Pattern 12: Find information and create a document
        pattern12 = r"(?:find|get|gather|collect)\s+(?:information|data|content|details)\s+(?:about|on|for)\s+(?:[\w\s\d\-\+]+)\s+(?:and|then)\s+(?:create|write|prepare|make)\s+(?:a|an|the)\s+(?:summary|report|analysis|document|file)"
        if re.search(pattern12, task_description, re.IGNORECASE):
            logger.info(f"Detected complex file creation task with information gathering: '{task_description}'. Handling directly.")
            return True
            
        # Pattern 13: Summarize web content
        pattern13 = r"(?:summarize|analyze|extract)\s+(?:information|data|content|details)\s+(?:from|about|on)\s+(?:[\w\s\d\-\+]+)\s+(?:and|then)?\s+(?:save|write|create|put\s+it\s+in)\s+(?:a|an|the)?\s+(?:file|document|summary|report)"
        if re.search(pattern13, task_description, re.IGNORECASE):
            logger.info(f"Detected complex file creation task with content summarization: '{task_description}'. Handling directly.")
            return True
        
        # Fallback pattern: If it contains create/write/save and doesn't look like a web search
        web_patterns = [r"search", r"find", r"look\s+up", r"browse", r"internet", r"web", r"online", r"information about", r"articles on"]
        has_web_term = any(re.search(p, task_description, re.IGNORECASE) for p in web_patterns)
        
        # Check for file creation terms
        file_creation_terms = ["create", "write", "save", "store", "output", "generate", "compile", "summarize", "analyze", "extract"]
        has_file_creation_term = any(term in task_description.lower() for term in file_creation_terms)
        
        # Check for content type terms that suggest file creation
        content_type_terms = ["story", "poem", "essay", "article", "report", "note", "text", "document", "analysis", 
                             "summary", "list", "compilation", "collection", "information", "data", "content", "details"]
        has_content_type_term = any(term in task_description.lower() for term in content_type_terms)
        
        # Check for output file terms
        output_file_terms = ["file", "document", "txt", "output", "save as", "save to", "write to", "report", "summary", "analysis"]
        has_output_file_term = any(term in task_description.lower() for term in output_file_terms)
        
        # Check for terms that suggest the task is about creating a document from web content
        web_to_file_terms = ["based on search", "from web", "from the internet", "from online", "using search results", 
                            "from search results", "search and save", "find and save", "research and write", 
                            "look up and create", "search and create"]
        has_web_to_file_term = any(term in task_description.lower() for term in web_to_file_terms)
        
        # Special case 1: If the task has both web terms AND file creation terms with output file terms,
        # it's likely a complex task that should be handled as file creation
        if has_web_term and has_file_creation_term and has_output_file_term:
            logger.info(f"Detected complex file creation task with web research and file output: '{task_description}'. Handling directly.")
            return True
        
        # Special case 2: If the task has terms suggesting web-to-file workflow
        if has_web_to_file_term:
            logger.info(f"Detected web-to-file workflow task: '{task_description}'. Handling directly.")
            return True
        
        # Special case 3: If it has file creation terms and content type terms but no web terms
        if (has_file_creation_term and has_content_type_term) and not has_web_term:
            logger.info(f"Detected file creation task via fallback: '{task_description}'. Handling directly.")
            return True
        
        # Special case 4: If it has both file creation terms and output file terms
        if has_file_creation_term and has_output_file_term:
            logger.info(f"Detected file creation task with explicit output terms: '{task_description}'. Handling directly.")
            return True
        
        return False
    
    async def _handle_file_creation(self, task_description: str) -> Dict[str, Any]:
        """
        Handle file creation tasks directly, bypassing the task management system.
        This method overrides the parent class method to add enhanced functionality.
        
        Args:
            task_description: Description of the file creation task
            
        Returns:
            Dict containing the result of the file creation operation
        """
        logger.info(f"Handling file creation task directly: {task_description}")
        
        try:
            # Extract the filename from the task description using the enhanced method
            filename = self._extract_filename(task_description)
            result = await self.agentic_ollama.create_file(task_description, filename)
            
            # Return a properly formatted result
            success = result.get("success", False)
            message = result.get("message", "File creation completed")
            
            # Extract the result data
            result_data = {}
            if success and "result" in result and isinstance(result["result"], dict):
                result_data = {
                    "filename": result["result"].get("filename", "Unknown"),
                    "file_type": result["result"].get("file_type", "txt"),
                    "content_preview": result["result"].get("content_preview", "No preview available")
                }
            
            return {
                "success": success,
                "task_type": "file_creation",
                "result": result_data,
                "message": message
            }
            
        except Exception as e:
            logger.error(f"Error handling file creation task: {str(e)}")
            return {
                "success": False,
                "task_type": "file_creation",
                "error": str(e),
                "message": f"Failed to create file: {str(e)}"
            }
    
    def _extract_filename(self, task_description: str) -> str:
        """
        Extract the filename from a task description using multiple regex patterns.
        If no filename is found, generate a default one based on content type.
        
        Args:
            task_description: Description of the task
            
        Returns:
            Extracted or generated filename
        """
        logger.info(f"Extracting filename from: {task_description}")
        
        # Pattern 1: "save it to my [folder] as [filename]" - handles paths with quotes
        save_path_match = re.search(r'save\s+(?:it|this|the\s+\w+)?\s+(?:to|in)\s+(?:my\s+)?(?:[\w\s]+\s+)?folder\s+as\s+["\']+([\w\-\.\s]+\.\w+)["\']+', task_description, re.IGNORECASE)
        if save_path_match:
            filename = save_path_match.group(1).strip()
            logger.info(f"Extracted filename using pattern 1 (path with quotes): {filename}")
            return filename
        
        # Pattern 2: "save it to/as/in [filename]" - standard pattern
        save_as_match = re.search(r'save\s+(?:it|this|the\s+\w+)\s+(?:to|as|in)\s+["\']*([\w\-\.\s]+\.\w+)["\']*', task_description, re.IGNORECASE)
        if save_as_match:
            filename = save_as_match.group(1).strip()
            logger.info(f"Extracted filename using pattern 2 (standard save as): {filename}")
            return filename
        
        # Pattern 3: "save to/as/in [filename]" - shorter variant
        save_to_match = re.search(r'save\s+(?:to|as|in)\s+["\']*([\w\-\.\s]+\.\w+)["\']*', task_description, re.IGNORECASE)
        if save_to_match:
            filename = save_to_match.group(1).strip()
            logger.info(f"Extracted filename using pattern 3 (short save to): {filename}")
            return filename
        
        # Pattern 4: "create/write a [content] and save it as [filename]" - compound action
        create_save_match = re.search(r'(?:create|write)\s+a\s+[\w\s]+\s+(?:and|&)\s+save\s+(?:it|this)\s+(?:to|as|in)\s+["\']*([\w\-\.\s]+\.\w+)["\']*', task_description, re.IGNORECASE)
        if create_save_match:
            filename = create_save_match.group(1).strip()
            logger.info(f"Extracted filename using pattern 4 (compound action): {filename}")
            return filename
        
        # Pattern 5: "create/write a [content] called/named [filename]" - named content
        called_match = re.search(r'(?:create|write)\s+a\s+[\w\s]+\s+(?:called|named)\s+["\']+([\w\-\.\s]+\.\w+)["\']+', task_description, re.IGNORECASE)
        if called_match:
            filename = called_match.group(1).strip()
            logger.info(f"Extracted filename using pattern 5 (named content): {filename}")
            return filename
        
        # Pattern 6: "create/write [filename]" - direct file creation
        create_file_match = re.search(r'(?:create|write)\s+["\']*([\w\-\.\s]+\.\w+)["\']*', task_description, re.IGNORECASE)
        if create_file_match:
            filename = create_file_match.group(1).strip()
            logger.info(f"Extracted filename using pattern 6 (direct file): {filename}")
            return filename
        
        # Pattern 7: Look for any quoted text ending with a file extension
        quoted_filename_match = re.search(r'["\']+([\w\-\.\s]+\.\w+)["\']+', task_description, re.IGNORECASE)
        if quoted_filename_match:
            filename = quoted_filename_match.group(1).strip()
            logger.info(f"Extracted filename using pattern 7 (quoted text): {filename}")
            return filename
        
        # If no filename is found, generate a default one based on content type
        logger.info(f"No filename found in: {task_description}")
        content_type = self._detect_content_type(task_description)
        default_filename = f"{content_type}.txt"
        logger.info(f"No filename found, using default: {default_filename}")
        return default_filename
    
    def _detect_content_type(self, task_description: str) -> str:
        """
        Detect the content type from the task description.
        
        Args:
            task_description: Description of the task
            
        Returns:
            Detected content type (e.g., "essay", "story", "poem", etc.)
        """
        # Map of content types to their keywords
        content_types = {
            "essay": ["essay", "paper", "article", "composition"],
            "story": ["story", "tale", "narrative", "fiction"],
            "poem": ["poem", "poetry", "verse", "rhyme"],
            "report": ["report", "analysis", "summary", "review"],
            "letter": ["letter", "email", "correspondence"],
            "script": ["script", "screenplay", "dialogue"],
            "code": ["code", "program", "script", "function"],
            "recipe": ["recipe", "instructions", "steps", "ingredients"],
            "note": ["note", "memo", "reminder"],
            "document": ["document", "doc", "file"],
        }
        
        # Check for each content type
        for content_type, keywords in content_types.items():
            for keyword in keywords:
                if keyword in task_description.lower():
                    return content_type
        
        # Default to "document" if no content type is detected
        return "document"
    
    def _display_execution_results(self, workflow_id: str) -> Dict[str, Any]:
        """
        Display the execution results to the user.
        
        Args:
            workflow_id: ID of the workflow to display
            
        Returns:
            Dict containing the execution results
        """
        # Load the workflow
        self.task_manager.load_workflow(workflow_id)
        
        # Get all tasks
        tasks = self.task_manager.get_all_tasks()
        
        # Get workflow status
        status = self.task_manager.get_workflow_status()
        
        print("\n===== Task Execution Results =====")
        print(f"Workflow ID: {workflow_id}")
        print(f"Total Tasks: {status['total_tasks']}")
        print(f"Completed Tasks: {status['completed_tasks']}")
        print(f"Failed Tasks: {status['failed_tasks']}")
        print(f"Progress: {status['progress_percentage']}%")
        
        # Create a table to display the results
        table = Table(title="Task Execution Results")
        table.add_column("Step", style="cyan")
        table.add_column("Task", style="green")
        table.add_column("Status", style="yellow")
        table.add_column("Result", style="magenta")
        
        # Track successful tasks and their artifacts
        successful_tasks = []
        all_artifacts = {}
        
        # Add tasks to the table
        for i, task in enumerate(tasks, 1):
            # Format status
            status_str = task.status.value.upper()
            status_style = {
                TaskStatus.COMPLETED.value: "[bold green]",
                TaskStatus.FAILED.value: "[bold red]",
                TaskStatus.IN_PROGRESS.value: "[bold yellow]",
                TaskStatus.PENDING.value: "[bold blue]",
                TaskStatus.BLOCKED.value: "[bold magenta]"
            }.get(task.status.value, "")
            
            # Format result
            if task.result:
                if task.result.success:
                    result_str = "Success"
                    successful_tasks.append(task)
                    
                    # Collect artifacts
                    for key, value in task.result.artifacts.items():
                        if key != "full_result":  # Skip the full result
                            all_artifacts[f"{task.task_type}_{key}"] = value
                else:
                    result_str = f"Error: {task.result.error}"
            else:
                result_str = "No result"
            
            table.add_row(
                str(i),
                task.description[:50] + ("..." if len(task.description) > 50 else ""),
                f"{status_style}{status_str}[/]",
                result_str
            )
        
        # Display the table
        console.print(Panel(table, title="Task Execution Results", border_style="blue"))
        
        # Determine overall success
        overall_success = status["failed_tasks"] == 0 and status["completed_tasks"] > 0
        
        # Prepare summary message
        if overall_success:
            message = f"Successfully completed all {status['completed_tasks']} tasks."
            print(f"\n===== Success! =====\nAll {status['completed_tasks']} tasks completed successfully.")
        elif status["completed_tasks"] > 0:
            message = f"Partially completed {status['completed_tasks']} out of {status['total_tasks']} tasks. {status['failed_tasks']} tasks failed."
            print(f"\n===== Partial Success =====\nCompleted {status['completed_tasks']} out of {status['total_tasks']} tasks.")
            print(f"Failed tasks: {status['failed_tasks']}")
        else:
            message = f"Failed to complete any tasks. All {status['total_tasks']} tasks failed."
            print(f"\n===== Execution Failed =====\nAll {status['total_tasks']} tasks failed.")
        
        # Display artifacts from successful tasks
        if successful_tasks:
            console.print("[bold blue]Task Artifacts:[/bold blue]")
            print("\n----- Task Artifacts -----")
            
            # Track if we've already displayed a created file message
            displayed_file = False
            
            for task in successful_tasks:
                if task.result and task.result.artifacts:
                    print(f"\nTask: {task.description}")
                    # Display relevant artifacts based on task type
                    if task.task_type == "file_creation" and "filename" in task.result.artifacts:
                        filename = task.result.artifacts["filename"]
                        if filename:
                            console.print(f"[green]Created file:[/green] {filename}")
                            print(f"Created file: {filename}")
                            displayed_file = True
                            
                            # Show file type if available
                            if "file_type" in task.result.artifacts and task.result.artifacts["file_type"]:
                                file_type = task.result.artifacts["file_type"]
                                console.print(f"[blue]File type:[/blue] {file_type}")
                                print(f"File type: {file_type}")
                            
                            # Show content preview if available
                            if "content_preview" in task.result.artifacts and task.result.artifacts["content_preview"]:
                                preview = task.result.artifacts["content_preview"]
                                if isinstance(preview, str) and preview.strip():
                                    console.print("[yellow]Content preview:[/yellow]")
                                    console.print(f"{preview[:200]}..." if len(preview) > 200 else preview)
                                    print("Content preview:")
                                    print(f"{preview[:200]}..." if len(preview) > 200 else preview)
                    
                    elif task.task_type == "web_browsing" and "filename" in task.result.artifacts:
                        filename = task.result.artifacts["filename"]
                        if filename and not displayed_file:  # Only show if we haven't already displayed a file
                            console.print(f"[green]Saved web content to:[/green] {filename}")
                            print(f"Saved web content to: {filename}")
                            displayed_file = True
                        
                        # Show URL if available
                        if "url" in task.result.artifacts and task.result.artifacts["url"]:
                            url = task.result.artifacts["url"]
                            console.print(f"[blue]Source URL:[/blue] {url}")
                            print(f"Source URL: {url}")
                        
                        # Show sample headlines if available
                        if "headlines" in task.result.artifacts and task.result.artifacts["headlines"]:
                            console.print("[yellow]Sample headlines:[/yellow]")
                            print("Sample headlines:")
                            for headline in task.result.artifacts["headlines"][:3]:
                                console.print(f"- {headline}")
                                print(f"- {headline}")
                                
                        # Show information if available
                        if "information" in task.result.artifacts and task.result.artifacts["information"]:
                            console.print("[yellow]Information gathered:[/yellow]")
                            print("Information gathered:")
                            for info in task.result.artifacts["information"][:3]:
                                console.print(f"- {info[:100]}..." if len(info) > 100 else f"- {info}")
                                print(f"- {info[:100]}..." if len(info) > 100 else f"- {info}")
                    
                    elif task.task_type == "image_analysis" and "analysis" in task.result.artifacts:
                        analysis = task.result.artifacts["analysis"]
                        console.print(f"[green]Image analysis:[/green] {analysis[:100]}...")
                        print(f"Image analysis: {analysis[:100]}...")
                        
                        # Show image path if available
                        if "image_path" in task.result.artifacts and task.result.artifacts["image_path"]:
                            image_path = task.result.artifacts["image_path"]
                            console.print(f"[blue]Image path:[/blue] {image_path}")
                            print(f"Image path: {image_path}")
        
        # Return the overall result
        return {
            "success": overall_success,
            "task_type": "complex_task",
            "result": {
                "workflow_id": workflow_id,
                "completed_tasks": status["completed_tasks"],
                "failed_tasks": status["failed_tasks"],
                "total_tasks": status["total_tasks"],
                "artifacts": all_artifacts
            },
            "message": message
        }
    
    async def execute_task(self, task_description: str) -> Dict[str, Any]:
        """
        Override the original execute_task method to handle both simple and complex tasks.
        
        Args:
            task_description: Natural language description of the task to execute
            
        Returns:
            Dict containing the execution results
        """
        # First, check if this is a direct file creation task using our enhanced detection
        if self._is_direct_file_creation_task(task_description):
            logger.info(f"Detected direct file creation task: '{task_description}'. Handling directly.")
            print(f"\n===== Executing File Creation Task =====")
            print(f"Task: {task_description}")
            print("Handling as a direct file creation task...\n")
            # Use the file creation handler
            return await self._handle_file_creation(task_description)
        
        # Check if this is a complex task that should be broken down
        task_lower = task_description.lower()
        
        # Indicators of complex tasks
        complex_task_indicators = [
            # Multiple steps or actions
            "and then", "after that", "followed by", "next", "finally",
            # Multiple objectives
            "and also", "additionally", "as well as", "plus",
            # Complex research tasks
            "research and", "find information and", "gather data and", "search for information and",
            # Complex creation tasks
            "compile information", "compile solutions", "analyze", "determine", "summarize", "extract",
            # Explicit multi-step requests
            "multi-step", "multiple steps", "several steps", "first", "second", "third",
            # File creation after web browsing
            "save that", "save it", "save the results", "save to a file", "into a file", "create a file",
            # Web research and file creation combinations
            "search and save", "find and write", "research and create", "look up and save",
            "gather information and compile", "collect data and analyze", "find information and summarize"
        ]
        
        # Check for complex task indicators
        is_complex_task = any(indicator in task_lower for indicator in complex_task_indicators)
        
        # Check for multiple file names in the task description
        file_name_pattern = re.compile(r'(?:file|document|text)\s+(?:named|called)\s+["\']?([\w\s\.\-]+)["\']?', re.IGNORECASE)
        file_names = file_name_pattern.findall(task_description)
        has_multiple_files = len(file_names) > 1
        
        # If there are multiple file names mentioned, it's a complex task
        is_complex_task = is_complex_task or has_multiple_files
        
        # Check for complex tasks that involve both web browsing and file creation
        web_patterns = [r"search", r"find", r"look\s+up", r"browse", r"internet", r"web", r"online", 
                       r"information about", r"articles on", r"research", r"get\s+information", 
                       r"news\s+about", r"headlines", r"current\s+events"]
        has_web_term = any(re.search(p, task_description, re.IGNORECASE) for p in web_patterns)
        
        # Check for file creation terms
        file_creation_terms = ["create", "write", "save", "store", "output", "generate", "compile", 
                             "summarize", "analyze", "extract", "prepare", "make", "draft", 
                             "compose", "produce", "develop"]
        has_file_creation_term = any(term in task_lower for term in file_creation_terms)
        
        # Check for output file terms
        output_file_terms = ["file", "document", "txt", "output", "save as", "save to", "write to", 
                           "report", "summary", "analysis", "paper", "essay", "article", "story", 
                           "poem", "script", "letter", "memo", "note"]
        has_output_file_term = any(term in task_lower for term in output_file_terms)
        
        # Check for content type terms
        content_type_terms = ["story", "poem", "essay", "article", "report", "note", "text", "document", 
                            "analysis", "summary", "list", "compilation", "collection", "information", 
                            "data", "content", "details"]
        has_content_type_term = any(term in task_lower for term in content_type_terms)
        
        # Check for terms that suggest the task is about creating a document from web content
        web_to_file_terms = ["based on search", "from web", "from the internet", "from online", 
                            "using search results", "from search results", "search and save", 
                            "find and save", "research and write", "look up and create", "search and create"]
        has_web_to_file_term = any(term in task_lower for term in web_to_file_terms)
        
        # Special case: If the task has both web terms AND file creation terms with output file terms,
        # it's a complex task that should be handled as file creation or web browsing with file output
        if has_web_term and has_file_creation_term and (has_output_file_term or has_content_type_term):
            # Check if the task is primarily about web browsing with file output
            web_focused_terms = ["search for", "find information", "look up", "research", "browse", 
                               "get information", "find articles", "search the web", "look for", 
                               "find news", "get headlines", "check news", "find current events"]
            is_web_focused = any(term in task_lower for term in web_focused_terms)
            
            # Check if the task is primarily about file creation with web input
            file_focused_terms = ["create a report", "write a summary", "create a file", "write a document", 
                                "compile information", "write an article", "create a story", "write a poem", 
                                "draft an essay", "compose a letter", "make a list", "prepare a document", 
                                "develop a report", "produce a summary", "generate an analysis"]
            is_file_focused = any(term in task_lower for term in file_focused_terms)
            
            # Check for explicit web-to-file workflow indicators
            has_explicit_web_to_file = has_web_to_file_term
            
            # If it's more web-focused and not explicitly file-focused, handle it as a web browsing task
            if (is_web_focused and not is_file_focused) or has_explicit_web_to_file:
                logger.info(f"Detected complex task with web research and file output: '{task_description}'. Handling as web browsing with file output.")
                print(f"\n===== Executing Web Browsing Task with File Output =====")
                print(f"Task: {task_description}")
                print("Handling as a web browsing task that saves results to files...\n")
                
                # Create a web browser instance if needed
                if not hasattr(self, 'web_browser'):
                    from web_browsing import WebBrowser
                    self.web_browser = WebBrowser(self)
                
                # Use the web browser to handle the task
                try:
                    return await self.web_browser.browse_web(task_description)
                except Exception as e:
                    logger.error(f"Error in web browsing task: {str(e)}")
                    print(f"\nError in web browsing task: {str(e)}")
                    print("Trying as a file creation task instead...\n")
                    # Fallback to file creation if web browsing fails
                    return await self._handle_file_creation(task_description)
            else:
                # Otherwise, handle it as a file creation task
                logger.info(f"Detected complex task with web research and file output: '{task_description}'. Handling as file creation.")
                print(f"\n===== Executing Complex File Creation Task =====")
                print(f"Task: {task_description}")
                print("Handling as a file creation task with web research...\n")
                try:
                    return await self._handle_file_creation(task_description)
                except Exception as e:
                    logger.error(f"Error in file creation task: {str(e)}")
                    print(f"\nError in file creation task: {str(e)}")
                    print("Trying as a web browsing task instead...\n")
                    # Fallback to web browsing if file creation fails
                    if not hasattr(self, 'web_browser'):
                        from web_browsing import WebBrowser
                        self.web_browser = WebBrowser(self)
                    return await self.web_browser.browse_web(task_description)
        
        # If it's already identified as a complex task, handle it with the task management system
        if is_complex_task:
            logger.info(f"Detected complex task: '{task_description}'. Using task management system.")
            print(f"\n===== Executing Complex Task =====")
            print(f"Task: {task_description}")
            print("Breaking down into subtasks using task management system...\n")
            return await self.execute_complex_task(task_description)
        
        # If not a complex task, check if it's a web browsing task
        # These patterns strongly indicate a web browsing task
        web_browsing_patterns = [
            "browse", "visit", "go to", "open website", "check website", 
            "look at website", "get information from", "search on", 
            "find on", "read from", "get data from", "scrape", 
            "grab headlines", "get headlines", "get news from", 
            "check news on", "get articles from", "get content from"
        ]
        
        # Check for URLs in the task description
        url_pattern = re.compile(r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+', re.IGNORECASE)
        has_url = bool(url_pattern.search(task_description))
        
        # Check for web browsing patterns
        is_web_browsing = has_url or any(pattern in task_lower for pattern in web_browsing_patterns)
        
        # If it's a web browsing task, handle it directly
        if is_web_browsing:
            logger.info(f"Detected web browsing task: '{task_description}'. Handling directly.")
            print(f"\n===== Executing Web Browsing Task =====")
            print(f"Task: {task_description}")
            print("Handling as a web browsing task...\n")
            
            # Use our web browser to handle the task
            try:
                # Create a web browser instance if needed
                if not hasattr(self, 'web_browser'):
                    from web_browsing import WebBrowser
                    self.web_browser = WebBrowser(self)
                
                # Use the web browser to handle the task
                result = await self.web_browser.browse_web(task_description)
                
                # Display the results
                if result.get('success', False):
                    print("\n===== Web Browsing Task Results =====")
                    print(f"Success: {result.get('success', False)}")
                    print(f"Task Type: {result.get('task_type', 'web_browsing')}")
                    print(f"Message: {result.get('message', '')}")
                    
                    # Display artifacts if available
                    if 'artifacts' in result:
                        artifacts = result['artifacts']
                        print("\nArtifacts:")
                        
                        # Display filename if available
                        if 'filename' in artifacts:
                            print(f"  Filename: {artifacts.get('filename', 'N/A')}")
                        
                        # Display URL if available
                        if 'url' in artifacts:
                            print(f"  URL: {artifacts.get('url', 'N/A')}")
                        
                        # Display domain if available
                        if 'domain' in artifacts:
                            print(f"  Domain: {artifacts.get('domain', 'N/A')}")
                        
                        # Display headlines if available
                        if 'headlines' in artifacts and artifacts['headlines']:
                            print("\nHeadlines:")
                            for i, headline in enumerate(artifacts['headlines'][:5], 1):
                                print(f"  {i}. {headline}")
                        
                        # Display content preview if available
                        if 'content_preview' in artifacts:
                            print("\nContent Preview:")
                            print(f"  {artifacts.get('content_preview', 'N/A')}")
                        
                        # Display additional files if available
                        for key, value in artifacts.items():
                            if key.startswith('additional_file_'):
                                print(f"\nAdditional File: {key.replace('additional_file_', '')}")
                                print(f"  Path: {value}")
                        
                        # Display analysis if available
                        if 'analysis_file' in artifacts:
                            print("\nAnalysis File:")
                            print(f"  Path: {artifacts.get('analysis_file', 'N/A')}")
                            
                            if 'analysis_preview' in artifacts:
                                print("\nAnalysis Preview:")
                                print(f"  {artifacts.get('analysis_preview', 'N/A')}")
                else:
                    print("\n===== Web Browsing Task Failed =====")
                    print(f"Error: {result.get('error', 'Unknown error')}")
                    print(f"Message: {result.get('message', '')}")
                    
                    # If the web browsing task failed, try to handle it as a file creation task
                    # This is a fallback mechanism for cases where the task was misclassified
                    if has_file_creation_term or has_output_file_term:
                        logger.info(f"Web browsing task failed. Trying as file creation task: '{task_description}'")
                        print("\nWeb browsing task failed. Trying as file creation task...")
                        return await self._handle_file_creation(task_description)
                    
                    # If it's not clearly a file creation task, try to handle it as a complex task
                    # This is another fallback for cases where the task is too complex for direct handling
                    if is_complex_task:
                        logger.info(f"Web browsing task failed. Trying as complex task: '{task_description}'")
                        print("\nWeb browsing task failed. Trying to break down into subtasks...")
                        return await self.execute_complex_task(task_description)
                
                return result
            except Exception as e:
                logger.error(f"Error in web browsing task: {str(e)}")
                print(f"\n===== Web Browsing Task Failed =====")
                print(f"Error: {str(e)}")
                
                # If the web browsing task failed with an exception, try to handle it as a file creation task
                if has_file_creation_term or has_output_file_term:
                    logger.info(f"Web browsing task failed with exception. Trying as file creation task: '{task_description}'")
                    print("\nWeb browsing task failed with exception. Trying as file creation task...")
                    return await self._handle_file_creation(task_description)
                
                # If it's not clearly a file creation task, try to handle it as a complex task
                if is_complex_task:
                    logger.info(f"Web browsing task failed with exception. Trying as complex task: '{task_description}'")
                    print("\nWeb browsing task failed with exception. Trying to break down into subtasks...")
                    return await self.execute_complex_task(task_description)
                
                return {
                    "success": False,
                    "task_type": "web_browsing",
                    "message": f"Error browsing the web: {str(e)}",
                    "artifacts": {}
                }
        
        # Also check for multiple action verbs as an indicator of complexity
        action_verbs = ["find", "search", "analyze", "organize", "delete", "browse", "visit", 
                       "gather", "collect", "download", "compile", "summarize"]
        
        # Count action verbs (excluding create/write/save which are handled by direct file creation)
        verb_count = sum(1 for verb in action_verbs if verb in task_lower)
        
        # If there are multiple action verbs, it's a complex task
        if verb_count >= 2:
            logger.info(f"Detected complex task with multiple action verbs: '{task_description}'. Using task management system.")
            print(f"\n===== Executing Complex Task =====")
            print(f"Task: {task_description}")
            print("Breaking down into subtasks using task management system...\n")
            return await self.execute_complex_task(task_description)
        
        # For simple tasks that don't match any of the above patterns, use the original implementation
        logger.info(f"Detected simple task: '{task_description}'. Using standard execution.")
        print(f"\n===== Executing Simple Task =====")
        print(f"Task: {task_description}")
        print("Using standard execution...\n")
        return await super().execute_task(task_description)

async def enhanced_agentic_assistant_mode(model: Optional[str] = None):
    """
    Enter interactive Enhanced Agentic Assistant mode.
    
    Args:
        model: The Ollama model to use for task execution
    """
    console.print(Panel(
        "[bold green]Enhanced Agentic Assistant Mode[/bold green]\n\n"
        "This assistant can help you with various tasks including:\n"
        "- Creating files with specific content\n"
        "- Analyzing images\n"
        "- Organizing files\n"
        "- Browsing websites and gathering information\n"
        "- Executing complex, multi-step tasks\n\n"
        "Type 'exit' or 'quit' to leave assistant mode.",
        title="Ollama Shell",
        border_style="blue"
    ))
    
    # Initialize the enhanced assistant
    assistant = EnhancedAgenticAssistant(model)
    
    while True:
        # Get user input
        task = Prompt.ask("[bold blue]What would you like me to do?[/bold blue]")
        
        # Check for exit command
        if task.lower() in ["exit", "quit", "bye", "goodbye"]:
            console.print("[bold green]Exiting Enhanced Agentic Assistant mode. Goodbye![/bold green]")
            break
        
        try:
            # Execute the task
            result = await assistant.execute_task(task)
            
            # Display the result
            display_agentic_assistant_result(result)
            
        except Exception as e:
            console.print(f"[bold red]Error executing task:[/bold red] {str(e)}")

def display_agentic_assistant_result(result: Dict[str, Any]):
    """
    Display the results of a task execution.
    
    Args:
        result: The task execution result dictionary
    """
    # Import from the original module to ensure consistent display
    from agentic_assistant import display_agentic_assistant_result as original_display
    
    # Use the original display function
    original_display(result)

async def handle_enhanced_agentic_assistant_task(task: str, model: Optional[str] = None) -> Dict[str, Any]:
    """
    Handle a single task execution request using the enhanced assistant.
    
    Args:
        task: The task description to execute
        model: The Ollama model to use (optional)
        
    Returns:
        Dict containing the execution results
    """
    try:
        # Initialize the enhanced assistant
        assistant = EnhancedAgenticAssistant(model)
        
        # Execute the task
        return await assistant.execute_task(task)
    
    except Exception as e:
        logger.error(f"Error handling task: {str(e)}")
        return {
            "success": False,
            "task_type": "unknown",
            "error": str(e),
            "message": f"Failed to execute task: {str(e)}"
        }

if __name__ == "__main__":
    # Check if a task was provided as an argument
    if len(sys.argv) > 1:
        # Get the task from command line arguments
        task = " ".join(sys.argv[1:])
        
        # Execute the task
        result = asyncio.run(handle_enhanced_agentic_assistant_task(task))
        
        # Display the result
        display_agentic_assistant_result(result)
    else:
        # Enter interactive mode
        asyncio.run(enhanced_agentic_assistant_mode())
